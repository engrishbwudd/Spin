Add this CSS right under your existing styles, near the end of the <style> block:

/* === QoL Additions === */
.rate-line {
    margin-top: 6px;
    font-size: 0.9em;
    opacity: 0.9;
}

.quick-row {
    display: flex;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap;
}

.pity-wrap {
    margin: 12px 0 0 0;
}

.pity-bar {
    display: grid;
    grid-template-columns: 90px 1fr 60px;
    align-items: center;
    gap: 10px;
    margin: 6px 0;
    font-size: 0.9em;
}
.pity-bar .label { opacity: 0.85; }
.pity-bar .track {
    height: 10px;
    background: rgba(255,255,255,0.15);
    border-radius: 999px;
    overflow: hidden;
}
.pity-bar .fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #4ECDC4, #FFD700);
    transition: width 0.25s ease;
}

.starline {
    font-size: 0.95em;
    opacity: 0.95;
    margin-top: 4px;
}

.toast {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    padding: 10px 16px;
    border-radius: 10px;
    font-size: 0.95em;
    z-index: 1100;
    display: none;
}
.toast.show { display: block; animation: fadeIn 0.2s ease; }

.stat-box.gold { border: 1px solid rgba(255,215,0,0.35); }


Add these small UI elements inside .game-container, right under your Roll button:

<div class="quick-row">
  <button class="roll-button" id="roll10Button">âš¡ QUICK ROLL Ã—10</button>
</div>

<div class="rate-line" id="rateLine">Rates: â€¦</div>

<div class="pity-wrap">
  <div class="pity-bar">
    <div class="label">EPIC pity</div>
    <div class="track"><div class="fill" id="epicPityFill"></div></div>
    <div class="count" id="epicPityText">0/25</div>
  </div>
  <div class="pity-bar">
    <div class="label">LEG pity</div>
    <div class="track"><div class="fill" id="legPityFill"></div></div>
    <div class="count" id="legPityText">0/100</div>
  </div>
  <div class="pity-bar">
    <div class="label">MYTH pity</div>
    <div class="track"><div class="fill" id="mythPityFill"></div></div>
    <div class="count" id="mythPityText">0/350</div>
  </div>
</div>


If you want to show how many unique characters heâ€™s found, toss one more stat card into your .stats block:

<div class="stat-box gold">
  <div>Unique Found</div>
  <div style="font-size:1.5em;font-weight:bold;" id="uniqueCount">0</div>
</div>


Now, the JavaScript. Drop these new globals near the top of your <script> (after your existing let declarations is fine):

// === Progress & persistence ===
let characterCounts = {}; // { [name]: pulls }
let pity = { epic: 0, legendary: 0, mythic: 0 };
const pityThresholds = { epic: 25, legendary: 100, mythic: 350 };

// Dupe refunds keep dupes meaningful
const dupePotionRefund = { common: 1, uncommon: 2, rare: 5, epic: 12, legendary: 30, mythic: 80 };
// Optional bonus for first-time pulls (feels great)
const firstTimeBonus = 3;

// Save/Load
function saveState() {
    const payload = {
        totalRolls, luckPotions, wheelEnabled,
        collection, upgradeLevels, characterCounts, pity
    };
    localStorage.setItem('ibr_state', JSON.stringify(payload));
}
function loadState() {
    const raw = localStorage.getItem('ibr_state');
    if (!raw) return;
    try {
        const s = JSON.parse(raw);
        totalRolls = s.totalRolls ?? totalRolls;
        luckPotions = s.luckPotions ?? luckPotions;
        wheelEnabled = s.wheelEnabled ?? wheelEnabled;
        collection = s.collection ?? collection;
        upgradeLevels = s.upgradeLevels ?? upgradeLevels;
        characterCounts = s.characterCounts ?? characterCounts;
        pity = s.pity ?? pity;

        // UI sync
        document.getElementById('totalRolls').textContent = totalRolls;
        document.getElementById('luckPotions').textContent = luckPotions;
        for (const k of Object.keys(collection)) {
            const el = document.getElementById(k + 'Count');
            if (el) el.textContent = collection[k];
        }
        updateUpgradeButtons();
        updateRateLine();
        updatePityUI();
        updateUniqueCount();
    } catch(e) {
        console.warn('Load failed', e);
    }
}


Add these helpers anywhere in the script section:

function formatPct(x) {
    return (x * 100).toFixed(x < 0.01 ? 3 : 2) + '%';
}

function updateRateLine() {
    const ch = calculateChances();
    const line = `Rates: C ${formatPct(ch.common)} / U ${formatPct(ch.uncommon)} / R ${formatPct(ch.rare)} / E ${formatPct(ch.epic)} / L ${formatPct(ch.legendary)} / M ${formatPct(ch.mythic)}`;
    document.getElementById('rateLine').textContent = line;
}

function updatePityUI() {
    const ePct = Math.min(100, (pity.epic / pityThresholds.epic) * 100);
    const lPct = Math.min(100, (pity.legendary / pityThresholds.legendary) * 100);
    const mPct = Math.min(100, (pity.mythic / pityThresholds.mythic) * 100);
    document.getElementById('epicPityFill').style.width = ePct + '%';
    document.getElementById('legPityFill').style.width = lPct + '%';
    document.getElementById('mythPityFill').style.width = mPct + '%';
    document.getElementById('epicPityText').textContent = `${pity.epic}/${pityThresholds.epic}`;
    document.getElementById('legPityText').textContent = `${pity.legendary}/${pityThresholds.legendary}`;
    document.getElementById('mythPityText').textContent = `${pity.mythic}/${pityThresholds.mythic}`;
}

function updateUniqueCount() {
    const count = Object.keys(characterCounts).length;
    const el = document.getElementById('uniqueCount');
    if (el) el.textContent = count;
}

function toast(msg, ms=1600) {
    let t = document.getElementById('toaster');
    if (!t) {
        t = document.createElement('div');
        t.id = 'toaster';
        t.className = 'toast';
        document.body.appendChild(t);
    }
    t.textContent = msg;
    t.classList.add('show');
    setTimeout(() => t.classList.remove('show'), ms);
}


Patch your calculateChances() so the UI line stays accurate after upgrades. You already return the chances; weâ€™ll just call updateRateLine() whenever upgrades change. At the end of updateUpgradeButtons() add:

updateRateLine();
saveState();


Now weâ€™re going to add pity + dupe logic and star ranks. Replace your current roll() function with this version. It keeps your animation path but injects all the good stuff:

function roll() {
    if (isRolling) return;
    isRolling = true;
    document.getElementById('rollButton').disabled = true;

    totalRolls++;
    luckPotions++; // baseline drip
    // Pity meters tick before outcome
    pity.epic++;
    pity.legendary++;
    pity.mythic++;

    const chances = calculateChances();

    // Decide rarity with pity guarantees
    let result = null;
    if (pity.mythic >= pityThresholds.mythic) {
        result = 'mythic';
    } else if (pity.legendary >= pityThresholds.legendary) {
        result = 'legendary';
    } else if (pity.epic >= pityThresholds.epic) {
        result = 'epic';
    } else {
        // normal RNG
        const random = Math.random();
        let cumulative = 0;
        const order = ['mythic', 'legendary', 'epic', 'rare', 'uncommon', 'common'];
        for (let rarity of order) {
            cumulative += chances[rarity];
            if (random <= cumulative) {
                result = rarity;
                break;
            }
        }
    }

    // Pick a character
    const charList = characters[result];
    const character = charList[Math.floor(Math.random() * charList.length)];

    // Collection and dupes
    const alreadyHad = !!characterCounts[character.name];
    characterCounts[character.name] = (characterCounts[character.name] || 0) + 1;

    // Rarity counts (keeps your grid behavior as "total pulled")
    collection[result]++;
    document.getElementById(result + 'Count').textContent = collection[result];

    // Refund potions on dupes, bonus on first-time
    if (alreadyHad) {
        const refund = dupePotionRefund[result] || 0;
        if (refund > 0) {
            luckPotions += refund;
            // weâ€™ll show it in popup message
            character._dupeRefund = refund;
        }
    } else {
        luckPotions += firstTimeBonus;
        character._firstTimeBonus = firstTimeBonus;
    }

    // Reset pity appropriately
    if (result === 'epic') {
        pity.epic = 0;
    } else if (result === 'legendary') {
        pity.epic = 0; pity.legendary = 0;
    } else if (result === 'mythic') {
        pity.epic = 0; pity.legendary = 0; pity.mythic = 0;
    }
    updatePityUI();

    // Update stats/potions
    document.getElementById('totalRolls').textContent = totalRolls;
    document.getElementById('luckPotions').textContent = luckPotions;
    updateUniqueCount();
    updateUpgradeButtons(); // also updates rates
    saveState();

    // Animate or not
    if (wheelEnabled) {
        const wheel = document.getElementById('wheel');
        const spins = 5 + Math.random() * 5;
        const finalAngle = Math.random() * 360;
        wheel.style.transform = `rotate(${spins * 360 + finalAngle}deg)`;
        setTimeout(() => {
            showResult(result, character);
            isRolling = false;
            document.getElementById('rollButton').disabled = false;
        }, 3000);
    } else {
        showResult(result, character);
        isRolling = false;
        document.getElementById('rollButton').disabled = false;
    }
}


Update showResult so it displays stars and shows dupe/first-time notes. Replace your function with this:

function showResult(rarity, character, opts = {}) {
    const suppressPopups = opts.suppressPopups === true;

    const resultDisplay = document.getElementById('resultDisplay');
    const rarityLabel = document.getElementById('rarityLabel');
    const characterName = document.getElementById('characterName');
    const characterImage = document.getElementById('characterImage');

    resultDisplay.className = 'result-display active ' + rarity;
    rarityLabel.textContent = rarity.toUpperCase();

    const pulls = characterCounts[character.name] || 1;
    const stars = Math.max(0, pulls - 1); // first copy = 0 stars
    const starText = stars > 0 ? `  ${'â˜…'.repeat(Math.min(stars,5))}${stars > 5 ? ' +' + (stars-5) : ''}` : '';
    characterName.textContent = character.name + starText;

    if (character.image && !character.image.includes('IMAGE_URL')) {
        characterImage.style.backgroundImage = `url('${character.image}')`;
        characterImage.innerHTML = '';
    } else {
        characterImage.style.backgroundImage = '';
        characterImage.innerHTML = character.emoji || 'â“';
    }

    if (!suppressPopups && (rarity === 'epic' || rarity === 'legendary' || rarity === 'mythic')) {
        // enrich popup messaging
        const overlay = document.getElementById('popupOverlay');
        const popupRarity = document.getElementById('popupRarity');
        const popupCharacter = document.getElementById('popupCharacter');
        const popupMessage = document.getElementById('popupMessage');
        const popupTitle = document.getElementById('popupTitle');
        const popupImage = document.getElementById('popupImage');

        const messages = {
            epic:  { title: "MAMMA MIA! ðŸ¤Œ", msg: character.description || "Che bello! You found an EPIC creature!" },
            legendary: { title: "ðŸ”¥ INCREDIBILE! ðŸ”¥", msg: character.description || "LEGENDARY! Absolutely pazzo!" },
            mythic: { title: "âš¡ MOLTO BENE!!! âš¡", msg: character.description || "MYTHIC!!! IMPOSSIBILE!" }
        };

        popupTitle.innerHTML = messages[rarity].title;
        popupRarity.textContent = rarity.toUpperCase();
        popupRarity.className = rarity;
        popupCharacter.textContent = character.name + starText;

        let note = messages[rarity].msg;
        if (character._dupeRefund) note += `  â€¢ Duplicate refund: +${character._dupeRefund} ðŸ§ª`;
        if (character._firstTimeBonus) note += `  â€¢ New find bonus: +${character._firstTimeBonus} ðŸ§ª`;
        popupMessage.textContent = note;

        if (character.image && !character.image.includes('IMAGE_URL')) {
            popupImage.style.backgroundImage = `url('${character.image}')`;
            popupImage.innerHTML = '';
        } else {
            popupImage.style.backgroundImage = '';
            popupImage.innerHTML = character.emoji || 'â“';
            popupImage.style.fontSize = '100px';
            popupImage.style.display = 'flex';
            popupImage.style.alignItems = 'center';
            popupImage.style.justifyContent = 'center';
        }

        overlay.classList.add('active');
    }
}


Add a Quick Roll Ã—10 that skips animation, does the pity/dupe math correctly, and shows a compact summary. Put this after showResult:

document.getElementById('roll10Button').addEventListener('click', rollBatch10);

function rollOnceCore(skipAnimation=true, suppressPopups=true) {
    // this calls your roll path but without UI delays
    // increment totals and pity just like in roll()
    totalRolls++;
    luckPotions++;
    pity.epic++; pity.legendary++; pity.mythic++;

    const chances = calculateChances();
    let result = null;
    if (pity.mythic >= pityThresholds.mythic) {
        result = 'mythic';
    } else if (pity.legendary >= pityThresholds.legendary) {
        result = 'legendary';
    } else if (pity.epic >= pityThresholds.epic) {
        result = 'epic';
    } else {
        const random = Math.random();
        let cumulative = 0;
        const order = ['mythic', 'legendary', 'epic', 'rare', 'uncommon', 'common'];
        for (let rarity of order) {
            cumulative += chances[rarity];
            if (random <= cumulative) { result = rarity; break; }
        }
    }

    const charList = characters[result];
    const character = charList[Math.floor(Math.random() * charList.length)];
    const alreadyHad = !!characterCounts[character.name];
    characterCounts[character.name] = (characterCounts[character.name] || 0) + 1;

    collection[result]++;

    if (alreadyHad) {
        luckPotions += dupePotionRefund[result] || 0;
    } else {
        luckPotions += firstTimeBonus;
    }

    if (result === 'epic') {
        pity.epic = 0;
    } else if (result === 'legendary') {
        pity.epic = 0; pity.legendary = 0;
    } else if (result === 'mythic') {
        pity.epic = 0; pity.legendary = 0; pity.mythic = 0;
    }

    return { rarity: result, character, alreadyHad };
}

function rollBatch10() {
    if (isRolling) return;
    const prevWheel = wheelEnabled;
    wheelEnabled = false;

    let tally = { common:0, uncommon:0, rare:0, epic:0, legendary:0, mythic:0, new:0, dupes:0 };
    for (let i=0;i<10;i++) {
        const r = rollOnceCore(true,true);
        tally[r.rarity]++;
        if (r.alreadyHad) tally.dupes++; else tally.new++;
    }

    // Update UI at once
    document.getElementById('totalRolls').textContent = totalRolls;
    document.getElementById('luckPotions').textContent = luckPotions;
    for (const k of Object.keys(collection)) {
        const el = document.getElementById(k + 'Count');
        if (el) el.textContent = collection[k];
    }
    updatePityUI();
    updateUpgradeButtons();
    updateUniqueCount();
    saveState();

    // Show last roll's card briefly so it doesn't feel sterile
    const lastChar = Object.keys(characterCounts).length ? null : null; // not used; keep simple
    toast(`Ã—10 Summary â†’ C:${tally.common} U:${tally.uncommon} R:${tally.rare} E:${tally.epic} L:${tally.legendary} M:${tally.mythic}  â€¢ New:${tally.new} Dupes:${tally.dupes}`, 2200);

    wheelEnabled = prevWheel;
}


Finally, call loadState() once after your current initialization so old progress loads before the first interaction. At the very bottom of your script, replace your current init lines with:

// Initialize
initWheel();
loadState();
updateUpgradeButtons();
updateRateLine();
updatePityUI();
updateUniqueCount();


Thatâ€™s the minimal set that transforms the loop from â€œpress button, prayâ€ into â€œpress button, progress.â€ Jonah will see rates, watch pity build, and cash dupes into more upgrades instead of groaning. Heâ€™ll also get that dopamine hit from starâ€‘ranking his favorites.